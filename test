import { render, fireEvent, waitFor } from '@testing-library/react';
import BenchmarkHubView from './benchmark-hub-view';  // Your component
import { QueryClient, QueryClientProvider } from 'react-query';
import { vi } from 'vitest';
import React from 'react';

// Mocking React's useState
const mockSetState = vi.fn();

vi.spyOn(React, 'useState').mockImplementation((initial) => [initial, mockSetState]);

const queryClient = new QueryClient();

const TestComponent = () => (
  <QueryClientProvider client={queryClient}>
    <BenchmarkHubView />
  </QueryClientProvider>
);

describe('BenchmarkHubView Component', () => {

  beforeEach(() => {
    vi.clearAllMocks(); // Reset all mocks before each test
  });

  it('should render the BenchmarkHubView component correctly', async () => {
    const { getByText } = render(<TestComponent />);
    
    await waitFor(() => {
      expect(getByText(/Benchmark/i)).toBeInTheDocument();
      expect(getByText(/Hub/i)).toBeInTheDocument();
    });
  });

  it('should handle tab click and update selectedOption and breadcrumbItem', async () => {
    const { getByText } = render(<TestComponent />);

    // Simulate a click on a tab (example tab with text "Hub 1")
    const tab = getByText('Hub 1');
    fireEvent.click(tab);

    await waitFor(() => {
      expect(mockSetState).toHaveBeenCalledWith('hub1');  // Expect state setter to be called
    });
  });

  it('should update the timezone when a new option is selected', async () => {
    const { getByRole } = render(<TestComponent />);
    const timeZoneDropdown = getByRole('combobox');  // Assuming you use a select element for time zones

    fireEvent.change(timeZoneDropdown, { target: { value: 'America/New_York' } });

    await waitFor(() => {
      expect(mockSetState).toHaveBeenCalledWith('America/New_York');  // Expect state setter to be called
    });
  });

  it('should display an error message when error occurs', async () => {
    mockSetState.mockReturnValueOnce('Error Occurred');

    const { getByText } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByText('Error Occurred')).toBeInTheDocument();
    });
  });

  it('should display a success message when operation is successful', async () => {
    mockSetState.mockReturnValueOnce('Operation Successful');

    const { getByText } = render(<TestComponent />);

    await waitFor(() => {
      expect(getByText('Operation Successful')).toBeInTheDocument();
    });
  });
});
